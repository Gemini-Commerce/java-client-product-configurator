/*
 * Product Configurator Service
 * ## Introduction  This comprehensive guide will equip you with the knowledge to integrate and leverage our Product Configurator Service in your applications.  ## Quick Start  Get up and running in no time! Follow these steps to kickstart your integration:  1. **Authentication:** Obtain your integration JWT to authenticate your requests. 2. **Client Libraries:** Explore our GitHub repositories to grab client libraries in your preferred programming language. 3. **API Overview:** Familiarize yourself with our RESTful API using the OpenAPI specification.  ## Integration  ### API Overview  Our RESTful API is the gateway to unlocking the full potential of Product Configurator. Check out the detailed [API Reference](/docs/category/configurator) for a granular understanding of each endpoint and request/response format.  ### Client Libraries  To expedite your integration process, we provide client libraries for various programming languages. Find the one that suits your stack in our [GitHub repositories](https://github.com/Gemini-Commerce).  ### Authentication  Security is paramount. Learn how to authenticate your requests using JWT. This ensures a secure and reliable connection between your application and Product Configurator.  ## Configuration Management  ### Configurator Lifecycle  Understand the lifecycle of configurators, from draft to active and deleted. This flexibility allows you to manage configurations at your own pace.  ### Steps and Options  Configure product steps with ease and define options effortlessly. Explore the power of dependencies to create dynamic and intuitive configurations.  ### Matrices  Delve into matricesâ€”your secret weapon. Explore price and weight matrices, and learn how configured steps influence properties and pricing.  ### Price Management  Unleash dynamic pricing with our versatile price matrices. From fixed prices to incremental structures, adapt to diverse pricing models effortlessly.  ## Security  Your data is in safe hands. Discover how Product Configurator ensures security through JWT authentication, safeguarding your sensitive information.  ## Backward Compatibility  Stay ahead of the curve. Learn about our versioning strategy, providing backward compatibility while allowing our service to evolve seamlessly.  ## Developer Support  Have questions? Need assistance? Write to us at [info@gemini-commerce.com](mailto:info@gemini-commerce.com) and we will get back to you.
 *
 * The version of the OpenAPI document: v1
 * Contact: info@gemini-commerce.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import GeminiCommerce_ProductConfigurator.ApiCallback;
import GeminiCommerce_ProductConfigurator.ApiClient;
import GeminiCommerce_ProductConfigurator.ApiException;
import GeminiCommerce_ProductConfigurator.ApiResponse;
import GeminiCommerce_ProductConfigurator.Configuration;
import GeminiCommerce_ProductConfigurator.Pair;
import GeminiCommerce_ProductConfigurator.ProgressRequestBody;
import GeminiCommerce_ProductConfigurator.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.GooglerpcStatus;
import org.openapitools.client.model.MatrixListMatricesResponse;
import org.openapitools.client.model.ProductConfiguratorCreateMatrixRequest;
import org.openapitools.client.model.ProductConfiguratorListMatricesRequest;
import org.openapitools.client.model.ProductConfiguratorUpdateMatrixRequest;
import org.openapitools.client.model.ProductconfiguratormatrixEntity;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MatrixApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MatrixApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MatrixApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for productConfiguratorCreateMatrix
     * @param tenantId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorCreateMatrixCall(String tenantId, ProductConfiguratorCreateMatrixRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/matrix/create"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorCreateMatrixValidateBeforeCall(String tenantId, ProductConfiguratorCreateMatrixRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorCreateMatrix(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling productConfiguratorCreateMatrix(Async)");
        }

        return productConfiguratorCreateMatrixCall(tenantId, body, _callback);

    }

    /**
     * Create Matrix
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * @param tenantId  (required)
     * @param body  (required)
     * @return ProductconfiguratormatrixEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ProductconfiguratormatrixEntity productConfiguratorCreateMatrix(String tenantId, ProductConfiguratorCreateMatrixRequest body) throws ApiException {
        ApiResponse<ProductconfiguratormatrixEntity> localVarResp = productConfiguratorCreateMatrixWithHttpInfo(tenantId, body);
        return localVarResp.getData();
    }

    /**
     * Create Matrix
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * @param tenantId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;ProductconfiguratormatrixEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductconfiguratormatrixEntity> productConfiguratorCreateMatrixWithHttpInfo(String tenantId, ProductConfiguratorCreateMatrixRequest body) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorCreateMatrixValidateBeforeCall(tenantId, body, null);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create Matrix (asynchronously)
     * Establish a new matrix by specifying the tenant ID. Utilize a POST request with the required matrix details in the body for seamless customization and expansion of matrix configurations.
     * @param tenantId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorCreateMatrixAsync(String tenantId, ProductConfiguratorCreateMatrixRequest body, final ApiCallback<ProductconfiguratormatrixEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorCreateMatrixValidateBeforeCall(tenantId, body, _callback);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for productConfiguratorDeleteMatrix
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorDeleteMatrixCall(String tenantId, String matrixId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/matrix/{matrixId}"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()))
            .replace("{" + "matrixId" + "}", localVarApiClient.escapeString(matrixId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorDeleteMatrixValidateBeforeCall(String tenantId, String matrixId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorDeleteMatrix(Async)");
        }

        // verify the required parameter 'matrixId' is set
        if (matrixId == null) {
            throw new ApiException("Missing the required parameter 'matrixId' when calling productConfiguratorDeleteMatrix(Async)");
        }

        return productConfiguratorDeleteMatrixCall(tenantId, matrixId, _callback);

    }

    /**
     * Delete Matrix
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public Object productConfiguratorDeleteMatrix(String tenantId, String matrixId) throws ApiException {
        ApiResponse<Object> localVarResp = productConfiguratorDeleteMatrixWithHttpInfo(tenantId, matrixId);
        return localVarResp.getData();
    }

    /**
     * Delete Matrix
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Object> productConfiguratorDeleteMatrixWithHttpInfo(String tenantId, String matrixId) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorDeleteMatrixValidateBeforeCall(tenantId, matrixId, null);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete Matrix (asynchronously)
     * Remove a specific matrix by specifying the tenant and matrix IDs. Ensure precision in matrix management with a straightforward DELETE request, simplifying the elimination of unwanted matrix configurations.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorDeleteMatrixAsync(String tenantId, String matrixId, final ApiCallback<Object> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorDeleteMatrixValidateBeforeCall(tenantId, matrixId, _callback);
        Type localVarReturnType = new TypeToken<Object>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for productConfiguratorGetMatrix
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorGetMatrixCall(String tenantId, String matrixId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/matrix/{matrixId}"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()))
            .replace("{" + "matrixId" + "}", localVarApiClient.escapeString(matrixId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorGetMatrixValidateBeforeCall(String tenantId, String matrixId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorGetMatrix(Async)");
        }

        // verify the required parameter 'matrixId' is set
        if (matrixId == null) {
            throw new ApiException("Missing the required parameter 'matrixId' when calling productConfiguratorGetMatrix(Async)");
        }

        return productConfiguratorGetMatrixCall(tenantId, matrixId, _callback);

    }

    /**
     * Get Matrix
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @return ProductconfiguratormatrixEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ProductconfiguratormatrixEntity productConfiguratorGetMatrix(String tenantId, String matrixId) throws ApiException {
        ApiResponse<ProductconfiguratormatrixEntity> localVarResp = productConfiguratorGetMatrixWithHttpInfo(tenantId, matrixId);
        return localVarResp.getData();
    }

    /**
     * Get Matrix
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @return ApiResponse&lt;ProductconfiguratormatrixEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductconfiguratormatrixEntity> productConfiguratorGetMatrixWithHttpInfo(String tenantId, String matrixId) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorGetMatrixValidateBeforeCall(tenantId, matrixId, null);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Matrix (asynchronously)
     * Retrieve matrix details by specifying the tenant and matrix IDs. Utilize a GET request for a comprehensive view of matrix configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorGetMatrixAsync(String tenantId, String matrixId, final ApiCallback<ProductconfiguratormatrixEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorGetMatrixValidateBeforeCall(tenantId, matrixId, _callback);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for productConfiguratorListMatrices
     * @param tenantId  (required)
     * @param configuratorId  (required)
     * @param pageSize  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorListMatricesCall(String tenantId, String configuratorId, String pageSize, ProductConfiguratorListMatricesRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/configurator/{configuratorId}/page-size/{pageSize}/matrices"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()))
            .replace("{" + "configuratorId" + "}", localVarApiClient.escapeString(configuratorId.toString()))
            .replace("{" + "pageSize" + "}", localVarApiClient.escapeString(pageSize.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorListMatricesValidateBeforeCall(String tenantId, String configuratorId, String pageSize, ProductConfiguratorListMatricesRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorListMatrices(Async)");
        }

        // verify the required parameter 'configuratorId' is set
        if (configuratorId == null) {
            throw new ApiException("Missing the required parameter 'configuratorId' when calling productConfiguratorListMatrices(Async)");
        }

        // verify the required parameter 'pageSize' is set
        if (pageSize == null) {
            throw new ApiException("Missing the required parameter 'pageSize' when calling productConfiguratorListMatrices(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling productConfiguratorListMatrices(Async)");
        }

        return productConfiguratorListMatricesCall(tenantId, configuratorId, pageSize, body, _callback);

    }

    /**
     * List Matrices
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * @param tenantId  (required)
     * @param configuratorId  (required)
     * @param pageSize  (required)
     * @param body  (required)
     * @return MatrixListMatricesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public MatrixListMatricesResponse productConfiguratorListMatrices(String tenantId, String configuratorId, String pageSize, ProductConfiguratorListMatricesRequest body) throws ApiException {
        ApiResponse<MatrixListMatricesResponse> localVarResp = productConfiguratorListMatricesWithHttpInfo(tenantId, configuratorId, pageSize, body);
        return localVarResp.getData();
    }

    /**
     * List Matrices
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * @param tenantId  (required)
     * @param configuratorId  (required)
     * @param pageSize  (required)
     * @param body  (required)
     * @return ApiResponse&lt;MatrixListMatricesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MatrixListMatricesResponse> productConfiguratorListMatricesWithHttpInfo(String tenantId, String configuratorId, String pageSize, ProductConfiguratorListMatricesRequest body) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorListMatricesValidateBeforeCall(tenantId, configuratorId, pageSize, body, null);
        Type localVarReturnType = new TypeToken<MatrixListMatricesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Matrices (asynchronously)
     * Retrieve a list of matrices for a specific configurator based on tenant and configurator IDs. Customize results by specifying page size for efficient pagination. Submit an empty body to get all matrices associated with the configurator. Streamline matrix management effortlessly.
     * @param tenantId  (required)
     * @param configuratorId  (required)
     * @param pageSize  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorListMatricesAsync(String tenantId, String configuratorId, String pageSize, ProductConfiguratorListMatricesRequest body, final ApiCallback<MatrixListMatricesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorListMatricesValidateBeforeCall(tenantId, configuratorId, pageSize, body, _callback);
        Type localVarReturnType = new TypeToken<MatrixListMatricesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for productConfiguratorRemovePricelistFromMatrix
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param pricelistGrn  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorRemovePricelistFromMatrixCall(String tenantId, String matrixId, String pricelistGrn, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/matrix/{matrixId}/pricelist/{pricelistGrn}"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()))
            .replace("{" + "matrixId" + "}", localVarApiClient.escapeString(matrixId.toString()))
            .replace("{" + "pricelistGrn" + "}", localVarApiClient.escapeString(pricelistGrn.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorRemovePricelistFromMatrixValidateBeforeCall(String tenantId, String matrixId, String pricelistGrn, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorRemovePricelistFromMatrix(Async)");
        }

        // verify the required parameter 'matrixId' is set
        if (matrixId == null) {
            throw new ApiException("Missing the required parameter 'matrixId' when calling productConfiguratorRemovePricelistFromMatrix(Async)");
        }

        // verify the required parameter 'pricelistGrn' is set
        if (pricelistGrn == null) {
            throw new ApiException("Missing the required parameter 'pricelistGrn' when calling productConfiguratorRemovePricelistFromMatrix(Async)");
        }

        return productConfiguratorRemovePricelistFromMatrixCall(tenantId, matrixId, pricelistGrn, _callback);

    }

    /**
     * Remove Pricelist from Matrix
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param pricelistGrn  (required)
     * @return ProductconfiguratormatrixEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ProductconfiguratormatrixEntity productConfiguratorRemovePricelistFromMatrix(String tenantId, String matrixId, String pricelistGrn) throws ApiException {
        ApiResponse<ProductconfiguratormatrixEntity> localVarResp = productConfiguratorRemovePricelistFromMatrixWithHttpInfo(tenantId, matrixId, pricelistGrn);
        return localVarResp.getData();
    }

    /**
     * Remove Pricelist from Matrix
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param pricelistGrn  (required)
     * @return ApiResponse&lt;ProductconfiguratormatrixEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductconfiguratormatrixEntity> productConfiguratorRemovePricelistFromMatrixWithHttpInfo(String tenantId, String matrixId, String pricelistGrn) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorRemovePricelistFromMatrixValidateBeforeCall(tenantId, matrixId, pricelistGrn, null);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Remove Pricelist from Matrix (asynchronously)
     * Remove a specific pricelist from a matrix by specifying the tenant, matrix, and pricelist IDs. Use a DELETE request for precise management of pricelist configurations within your product configurator service.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param pricelistGrn  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorRemovePricelistFromMatrixAsync(String tenantId, String matrixId, String pricelistGrn, final ApiCallback<ProductconfiguratormatrixEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorRemovePricelistFromMatrixValidateBeforeCall(tenantId, matrixId, pricelistGrn, _callback);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for productConfiguratorUpdateMatrix
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorUpdateMatrixCall(String tenantId, String matrixId, ProductConfiguratorUpdateMatrixRequest body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/v1/{tenantId}/matrix/{matrixId}"
            .replace("{" + "tenantId" + "}", localVarApiClient.escapeString(tenantId.toString()))
            .replace("{" + "matrixId" + "}", localVarApiClient.escapeString(matrixId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "standardAuthorization", "APIAuthorization" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call productConfiguratorUpdateMatrixValidateBeforeCall(String tenantId, String matrixId, ProductConfiguratorUpdateMatrixRequest body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tenantId' is set
        if (tenantId == null) {
            throw new ApiException("Missing the required parameter 'tenantId' when calling productConfiguratorUpdateMatrix(Async)");
        }

        // verify the required parameter 'matrixId' is set
        if (matrixId == null) {
            throw new ApiException("Missing the required parameter 'matrixId' when calling productConfiguratorUpdateMatrix(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling productConfiguratorUpdateMatrix(Async)");
        }

        return productConfiguratorUpdateMatrixCall(tenantId, matrixId, body, _callback);

    }

    /**
     * Update Matrix
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param body  (required)
     * @return ProductconfiguratormatrixEntity
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ProductconfiguratormatrixEntity productConfiguratorUpdateMatrix(String tenantId, String matrixId, ProductConfiguratorUpdateMatrixRequest body) throws ApiException {
        ApiResponse<ProductconfiguratormatrixEntity> localVarResp = productConfiguratorUpdateMatrixWithHttpInfo(tenantId, matrixId, body);
        return localVarResp.getData();
    }

    /**
     * Update Matrix
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;ProductconfiguratormatrixEntity&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ProductconfiguratormatrixEntity> productConfiguratorUpdateMatrixWithHttpInfo(String tenantId, String matrixId, ProductConfiguratorUpdateMatrixRequest body) throws ApiException {
        okhttp3.Call localVarCall = productConfiguratorUpdateMatrixValidateBeforeCall(tenantId, matrixId, body, null);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update Matrix (asynchronously)
     * Modify an existing matrix by specifying the tenant and matrix IDs. Utilize a PUT request with updated matrix details in the body for seamless customization and fine-tuning of your product configurations. Keep your matrices in sync effortlessly.
     * @param tenantId  (required)
     * @param matrixId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request or Limit Exceeded </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> An internal error occurred is thrown when an incompatible payload is sent </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unexpected error response. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call productConfiguratorUpdateMatrixAsync(String tenantId, String matrixId, ProductConfiguratorUpdateMatrixRequest body, final ApiCallback<ProductconfiguratormatrixEntity> _callback) throws ApiException {

        okhttp3.Call localVarCall = productConfiguratorUpdateMatrixValidateBeforeCall(tenantId, matrixId, body, _callback);
        Type localVarReturnType = new TypeToken<ProductconfiguratormatrixEntity>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
